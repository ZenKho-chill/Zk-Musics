import { 
  EmbedBuilder,
  StringSelectMenuBuilder,
  StringSelectMenuOptionBuilder,
  ActionRowBuilder,
  ComponentType,
  StringSelectMenuInteraction,
  ButtonBuilder,
  ButtonStyle
} from "discord.js";
import { Manager } from "../../manager.js";
import { CommandHandler } from "../../structures/CommandHandler.js";
import { Config } from "../../@types/Config.js";
import { ConfigData } from "../../services/ConfigData.js";
import { logInfo, logDebug, logWarn, logError } from "../../utilities/Logger.js";

const data: Config = new ConfigData().data;

export class PlaylistEditorHandler {
  public async execute(client: Manager, handler: CommandHandler) {
    // L·∫•y t·∫•t c·∫£ playlists c·ªßa user
    const fullList = await client.db.playlist.all();
    const userPlaylists = fullList.filter((data) => {
      return data.value.owner == handler.user?.id;
    });

    if (!userPlaylists || userPlaylists.length === 0) {
      return handler.editReply({
        embeds: [
          new EmbedBuilder()
            .setDescription("‚ùå B·∫°n ch∆∞a c√≥ playlist n√†o ƒë·ªÉ ch·ªânh s·ª≠a!")
            .setColor(client.color_main),
        ],
      });
    }

    // T·∫°o dropdown v·ªõi c√°c playlist options (gi·ªõi h·∫°n 25 options c·ªßa Discord)
    const playlistOptions = userPlaylists.slice(0, 25).map((playlist, index) => {
      const createdDate = new Date(playlist.value.created);
      // Chuy·ªÉn sang timezone Vi·ªát Nam (UTC+7) v√† format th·ªß c√¥ng
      const vietnamTime = new Date(createdDate.getTime() + (7 * 60 * 60 * 1000));
      const day = vietnamTime.getUTCDate().toString().padStart(2, '0');
      const month = (vietnamTime.getUTCMonth() + 1).toString().padStart(2, '0');
      const year = vietnamTime.getUTCFullYear();
      const hours = vietnamTime.getUTCHours().toString().padStart(2, '0');
      const minutes = vietnamTime.getUTCMinutes().toString().padStart(2, '0');
      const formattedDate = `${day}/${month}/${year} ${hours}:${minutes}`;
      
      const privacy = playlist.value.private ? "üîí Ri√™ng t∆∞" : "üåê C√¥ng khai";
      
      return new StringSelectMenuOptionBuilder()
        .setLabel(`${playlist.value.name || playlist.value.id}`)
        .setDescription(`${playlist.value.tracks?.length || 0} b√†i ‚Ä¢ ${privacy} ‚Ä¢ ${formattedDate}`)
        .setValue(playlist.value.id);
    });

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId("playlist_select_editor")
      .setPlaceholder("Ch·ªçn playlist ƒë·ªÉ ch·ªânh s·ª≠a...")
      .addOptions(playlistOptions);

    const actionRow = new ActionRowBuilder<StringSelectMenuBuilder>()
      .addComponents(selectMenu);

    const embed = new EmbedBuilder()
      .setTitle("‚öôÔ∏è Ch·ªânh s·ª≠a playlist")
      .setDescription(
        `**T·ªïng s·ªë playlist:** ${userPlaylists.length}\n\n` +
        `Ch·ªçn playlist t·ª´ dropdown b√™n d∆∞·ªõi ƒë·ªÉ ch·ªânh s·ª≠a ƒë·ªô hi·ªÉn th·ªã:`
      )
      .setColor(client.color_main)
      .setFooter({
        text: userPlaylists.length > 25 ? `Hi·ªÉn th·ªã 25/${userPlaylists.length} playlist ƒë·∫ßu ti√™n` : `${userPlaylists.length} playlist`,
      });

    const response = await handler.editReply({
      embeds: [embed],
      components: [actionRow],
    });

    // Collector ƒë·ªÉ l·∫Øng nghe user ch·ªçn playlist
    const collector = response.createMessageComponentCollector({
      componentType: ComponentType.StringSelect,
      time: 300000, // 5 ph√∫t timeout
    });

    collector.on("collect", async (interaction: StringSelectMenuInteraction) => {
      if (interaction.user.id !== handler.user?.id) {
        return interaction.reply({
          content: "‚ùå B·∫°n kh√¥ng th·ªÉ s·ª≠ d·ª•ng dropdown n√†y!",
          ephemeral: true,
        });
      }

      const selectedPlaylistId = interaction.values[0];
      
      // Hi·ªÉn th·ªã options ƒë·ªÉ ch·ªânh s·ª≠a (bao g·ªìm disable dropdown)
      await this.showEditOptions(client, handler, interaction, selectedPlaylistId, selectMenu);
    });

    collector.on("end", async (_, reason) => {
      if (reason === "time") {
        selectMenu.setDisabled(true);
        const disabledRow = new ActionRowBuilder<StringSelectMenuBuilder>()
          .addComponents(selectMenu);

        const timeoutEmbed = new EmbedBuilder()
          .setDescription("‚è∞ Th·ªùi gian ch·ªçn playlist ƒë√£ h·∫øt!")
          .setColor(client.color_main);

        await handler.editReply({
          embeds: [timeoutEmbed],
          components: [disabledRow],
        }).catch(() => null);
      }
    });
  }

  private async showEditOptions(
    client: Manager,
    handler: CommandHandler,
    interaction: StringSelectMenuInteraction,
    playlistId: string,
    selectMenu: StringSelectMenuBuilder
  ) {
    const playlist = await client.db.playlist.get(playlistId);

    if (!playlist) {
      return interaction.update({
        embeds: [
          new EmbedBuilder()
            .setDescription(
              `${client.i18n.get(handler.language, "commands.playlist", "pl_editor_invalid")}`
            )
            .setColor(client.color_main),
        ],
        components: [],
      });
    }

    const currentPrivacy = playlist.private ? "üîí Ri√™ng t∆∞" : "üåê C√¥ng khai";
    
    const buttons = new ActionRowBuilder<ButtonBuilder>().addComponents([
      new ButtonBuilder()
        .setStyle(ButtonStyle.Primary)
        .setCustomId("set_public")
        .setLabel("ƒê·∫∑t C√¥ng khai")
        .setEmoji("üåê")
        .setDisabled(!playlist.private), // Disable n·∫øu ƒë√£ public
      new ButtonBuilder()
        .setStyle(ButtonStyle.Secondary)
        .setCustomId("set_private")
        .setLabel("ƒê·∫∑t Ri√™ng t∆∞")
        .setEmoji("üîí")
        .setDisabled(playlist.private), // Disable n·∫øu ƒë√£ private
    ]);

    const editEmbed = new EmbedBuilder()
      .setTitle("‚öôÔ∏è Ch·ªânh s·ª≠a ƒë·ªô hi·ªÉn th·ªã playlist")
      .setDescription(
        `üìù **Playlist:** ${playlist.name || playlist.id}\n` +
        `üÜî **ID:** ||${playlist.id}||\n` +
        `üéµ **S·ªë b√†i h√°t:** ${playlist.tracks?.length || 0}\n` +
        `üîí **Tr·∫°ng th√°i hi·ªán t·∫°i:** ${currentPrivacy}\n\n` +
        `Ch·ªçn tr·∫°ng th√°i m·ªõi cho playlist:`
      )
      .setColor(client.color_main);

    await interaction.update({
      embeds: [editEmbed],
      components: [buttons], // Ch·ªâ hi·ªÉn th·ªã buttons, x√≥a dropdown
    });

    const buttonCollector = interaction.message.createMessageComponentCollector({
      filter: (m) => m.user.id == handler.user?.id,
      time: 60000, // 1 ph√∫t timeout
    });

    buttonCollector.on("collect", async (buttonInteraction) => {
      const buttonId = buttonInteraction.customId;

      if (buttonId === "set_public") {
        try {
          // C√°ch 1: S·ª≠ d·ª•ng sub-key ƒë·ªÉ c·∫≠p nh·∫≠t tr·ª±c ti·∫øp
          await client.db.playlist.set(`${playlistId}.private`, false);
          
          // X√°c nh·∫≠n l·∫°i vi·ªác c·∫≠p nh·∫≠t
          const updatedPlaylist = await client.db.playlist.get(playlistId);
          logDebug("PlaylistEditorHandler", `Sau khi c·∫≠p nh·∫≠t v·ªõi sub-key - Playlist ${playlistId} private: ${updatedPlaylist?.private}`);
          
          // N·∫øu v·∫´n kh√¥ng work, th·ª≠ c√°ch 2
          if (updatedPlaylist?.private !== false) {
            logDebug("PlaylistEditorHandler", "Sub-key kh√¥ng work, th·ª≠ c√°ch 2 - full object update");
            updatedPlaylist.private = false;
            await client.db.playlist.set(playlistId, updatedPlaylist);
            
            // X√°c nh·∫≠n l·∫ßn cu·ªëi
            const finalCheck = await client.db.playlist.get(playlistId);
            logDebug("PlaylistEditorHandler", `Sau khi c·∫≠p nh·∫≠t full object - Playlist ${playlistId} private: ${finalCheck?.private}`);
          }
        } catch (error) {
          logError("PlaylistEditorHandler", "C·∫≠p nh·∫≠t playlist th·∫•t b·∫°i", { error });
        }
        
        const successEmbed = new EmbedBuilder()
          .setTitle("‚úÖ ƒê√£ c·∫≠p nh·∫≠t playlist")
          .setDescription(
            `${client.i18n.get(handler.language, "commands.playlist", "pl_editor_public", {
              playlist: playlist.name || playlistId,
            })}\n\n` +
            `üîç **Debug:** ƒê√£ th·ª≠ c·∫≠p nh·∫≠t playlist th√†nh c√¥ng khai`
          )
          .setColor("#00ff00");

        await buttonInteraction.update({
          embeds: [successEmbed],
          components: [], // X√≥a t·∫•t c·∫£ components
        });
        buttonCollector.stop();
      } else if (buttonId === "set_private") {
        try {
          // C√°ch 1: S·ª≠ d·ª•ng sub-key ƒë·ªÉ c·∫≠p nh·∫≠t tr·ª±c ti·∫øp  
          await client.db.playlist.set(`${playlistId}.private`, true);
          
          // X√°c nh·∫≠n l·∫°i vi·ªác c·∫≠p nh·∫≠t
          const updatedPlaylist = await client.db.playlist.get(playlistId);
          logDebug("PlaylistEditorHandler", `Sau khi c·∫≠p nh·∫≠t v·ªõi sub-key - Playlist ${playlistId} private: ${updatedPlaylist?.private}`);
          
          // N·∫øu v·∫´n kh√¥ng work, th·ª≠ c√°ch 2
          if (updatedPlaylist?.private !== true) {
            logDebug("PlaylistEditorHandler", "Sub-key kh√¥ng work, th·ª≠ c√°ch 2 - full object update");
            updatedPlaylist.private = true;
            await client.db.playlist.set(playlistId, updatedPlaylist);
            
            // X√°c nh·∫≠n l·∫ßn cu·ªëi
            const finalCheck = await client.db.playlist.get(playlistId);
            logDebug("PlaylistEditorHandler", `Sau khi c·∫≠p nh·∫≠t full object - Playlist ${playlistId} private: ${finalCheck?.private}`);
          }
        } catch (error) {
          logError("PlaylistEditorHandler", "C·∫≠p nh·∫≠t playlist th·∫•t b·∫°i", { error });
        }
        
        const successEmbed = new EmbedBuilder()
          .setTitle("‚úÖ ƒê√£ c·∫≠p nh·∫≠t playlist")
          .setDescription(
            `${client.i18n.get(handler.language, "commands.playlist", "pl_editor_private", {
              playlist: playlist.name || playlistId,
            })}`
          )
          .setColor("#00ff00");

        await buttonInteraction.update({
          embeds: [successEmbed],
          components: [], // X√≥a t·∫•t c·∫£ components
        });
        buttonCollector.stop();
      }
    });

    buttonCollector.on("end", async (_, reason) => {
      if (reason === "time") {
        const timeoutEmbed = new EmbedBuilder()
          .setTitle("‚è∞ H·∫øt th·ªùi gian ch·ªânh s·ª≠a")
          .setDescription(
            `Th·ªùi gian ch·ªânh s·ª≠a ƒë√£ h·∫øt!\n\n` +
            `üìù **Playlist:** ${playlist.name || playlist.id}\n` +
            `üîí **Tr·∫°ng th√°i:** Kh√¥ng thay ƒë·ªïi`
          )
          .setColor("#ffaa00");

        await handler.editReply({
          embeds: [timeoutEmbed],
          components: [], // X√≥a t·∫•t c·∫£ components khi timeout
        }).catch(() => null);
      }
    });
  }
}
